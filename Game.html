<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Audio-Dodger (MP3 → Level)</title>
<style>
  :root { --bg:#0b0b12; --fg:#e8e8f0; --muted:#8a8aa6; --accent:#7dd3fc; }
  * { box-sizing:border-box; }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  .ui {
    position: fixed; inset: 0; display: grid; place-items: center;
    padding: 16px; background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.6));
    z-index: 10;
  }
  .card {
    width:min(620px, 92vw); background:#111425; border:1px solid #1f233a; border-radius:16px; padding:16px 16px 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,.35);
  }
  h1 { margin: 6px 0 2px; font-size: 22px; }
  p { margin: 8px 0 10px; color: var(--muted); line-height:1.35; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
  input[type=file] {
    flex:1; padding:10px; border:1px dashed #2a2f52; border-radius:10px; background:#0f1230; color:#cfe6ff;
  }
  button {
    appearance: none; border:0; border-radius:12px; padding:12px 14px; font-weight:700;
    background: linear-gradient(180deg, #2cc6ff, #199bd6); color:#05121a; cursor:pointer;
  }
  button:disabled { filter:saturate(.2) brightness(.8); cursor:not-allowed; }
  #tips { font-size:13px; }
  #canvas { width:100vw; height:100vh; display:block; touch-action: none; }
  .hud {
    position:fixed; left:10px; top:8px; font-size:13px; color:#b9c2ff; text-shadow:0 2px 8px rgba(0,0,0,.6);
    z-index:1; user-select:none;
  }
  .bottom {
    position:fixed; left:50%; transform:translateX(-50%); bottom:10px; color:#aab; font-size:13px; opacity:.8;
    background:rgba(0,0,0,.25); padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.08);
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>
<div class="hud" id="hud">00:00 / 00:00</div>
<div class="bottom">Drag to move • Dodge the notes</div>

<div class="ui" id="ui">
  <div class="card">
    <h1>Audio-Dodger</h1>
    <p>Select an MP3 (or any audio file). I’ll analyze the energy peaks and spawn patterns in sync.</p>
    <div class="row">
      <input id="file" type="file" accept="audio/*" />
      <button id="buildBtn" disabled>Build & Play</button>
    </div>
    <p id="tips">Tip: Stronger beats create radial bursts. Quiet sections spawn fewer notes.</p>
    <p id="status"></p>
  </div>
</div>

<script>
(() => {
  // ===== Canvas setup (retina-safe) =====
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ===== UI elements =====
  const ui = document.getElementById('ui');
  const fileInput = document.getElementById('file');
  const buildBtn = document.getElementById('buildBtn');
  const statusEl = document.getElementById('status');
  const hud = document.getElementById('hud');

  let audioCtx, trackSource, trackBuffer, audioStarted = false;
  let levelEvents = [];  // {t, strength}
  let startAt = 0, startedAtCtxTime = 0;
  let playing = false;

  fileInput.addEventListener('change', () => {
    buildBtn.disabled = !fileInput.files?.[0];
  });

  buildBtn.addEventListener('click', async () => {
    try {
      buildBtn.disabled = true;
      statusEl.textContent = 'Decoding & analyzing...';
      await ensureAudioContext();

      const file = fileInput.files[0];
      const arrayBuffer = await file.arrayBuffer();
      trackBuffer = await audioCtx.decodeAudioData(arrayBuffer);

      // Analyze with an OfflineAudioContext for consistent results:
      statusEl.textContent = 'Scanning peaks...';
      levelEvents = await analyzeBuffer(trackBuffer);

      statusEl.textContent = `Found ${levelEvents.length} events • Generating patterns...`;
      // No heavy precompute needed—events are enough.
      startGame();
    } catch (err) {
      console.error(err);
      alert('Sorry, failed to decode or analyze that file.');
      buildBtn.disabled = false;
      statusEl.textContent = '';
    }
  });

  async function ensureAudioContext() {
    if (!audioCtx) {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioContext({ latencyHint: 'interactive' });
    }
    if (audioCtx.state !== 'running') {
      await audioCtx.resume(); // requires user gesture (button click) on iOS
    }
  }

  // ===== Simple beat/energy detection =====
  // Windowed RMS with adaptive threshold using moving average + std dev
  async function analyzeBuffer(buffer) {
    const sampleRate = buffer.sampleRate;
    const offline = new OfflineAudioContext(1, buffer.length, sampleRate);
    const src = offline.createBufferSource();
    src.buffer = buffer;
    const analyser = offline.createAnalyser();
    analyser.fftSize = 2048;
    src.connect(analyser);
    analyser.connect(offline.destination);
    src.start();

    const rendered = await offline.startRendering(); // not really needed for values, but ensures graph is processed

    const hop = 1024; // ~23ms @44.1kHz
    const data = new Float32Array(analyser.fftSize);
    const energies = [];
    for (let i = 0; i < buffer.length; i += hop) {
      analyser.getFloatTimeDomainData(data);
      // RMS of this window
      let sum = 0;
      for (let j = 0; j < data.length; j++) { const v = data[j]; sum += v*v; }
      const rms = Math.sqrt(sum / data.length);
      energies.push(rms);
    }

    // Smooth energies
    const smooth = movingAverage(energies, 4);
    // Adaptive threshold
    const window = 32;
    const events = [];
    for (let i = window; i < smooth.length; i++) {
      const seg = smooth.slice(i - window, i);
      const mean = avg(seg);
      const sd = stdev(seg, mean);
      const th = mean + sd * 1.2; // sensitivity
      const e = smooth[i];
      if (e > th && e > smooth[i-1] && e >= smooth[i+1]) {
        const t = (i * hop) / sampleRate;
        const strength = clamp((e - mean) / (sd + 1e-6), 0, 3);
        events.push({ t, strength });
        // skip a little to avoid double firing
        i += 3;
      }
    }
    return events;
  }

  function movingAverage(arr, n) {
    const out = [];
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
      sum += arr[i];
      if (i >= n) sum -= arr[i-n];
      out[i] = (i < n-1) ? sum / (i+1) : sum / n;
    }
    return out;
  }
  const avg = a => a.reduce((s,v)=>s+v,0)/a.length;
  const stdev = (a,m)=>Math.sqrt(a.reduce((s,v)=>s+(v-m)*(v-m),0)/a.length);
  const clamp = (v,lo,hi)=>Math.max(lo,Math.min(hi,v));

  // ===== Game objects =====
  const notes = [];
  const player = { x: innerWidth/2, y: innerHeight/2, r: 10, alive: true, iFrames: 0 };

  // touch/mouse move
  let pointer = null;
  function setPlayerFromEvent(e) {
    const pt = (e.touches && e.touches[0]) || e;
    const rect = canvas.getBoundingClientRect();
    player.x = clamp(pt.clientX - rect.left, 12, rect.width-12);
    player.y = clamp(pt.clientY - rect.top, 12, rect.height-12);
  }
  canvas.addEventListener('pointerdown', e => { pointer = true; setPlayerFromEvent(e); });
  canvas.addEventListener('pointermove', e => { if (pointer) setPlayerFromEvent(e); });
  addEventListener('pointerup', () => { pointer = false; });

  function reset() {
    notes.length = 0;
    player.alive = true; player.iFrames = 120;
  }

  function startGame() {
    reset();
    // Hide UI, show game
    ui.style.display = 'none';
    playAudio();
    loop();
  }

  function playAudio() {
    if (trackSource) { try { trackSource.stop(); } catch(_){} }
    trackSource = audioCtx.createBufferSource();
    trackSource.buffer = trackBuffer;
    trackSource.connect(audioCtx.destination);
    trackSource.start();
    startAt = 0;
    startedAtCtxTime = audioCtx.currentTime;
    playing = true;

    trackSource.onended = () => {
      playing = false;
      showEndScreen();
    }
  }

  function currentTime() {
    return (audioCtx.currentTime - startedAtCtxTime) + startAt;
  }

  // ===== Note spawning from events =====
  let nextEventIdx = 0;

  function spawnFromEvent(ev) {
    // Two styles: (1) radial burst, (2) arc from one side
    const cx = innerWidth/2, cy = innerHeight/2;
    const s = ev.strength;
    const burstCount = Math.floor(4 + s * 6);
    if (s > 1.4) {
      // radial burst at center
      for (let i = 0; i < burstCount; i++) {
        const ang = (i / burstCount) * Math.PI*2 + (Math.random()*0.2);
        notes.push(new Note(cx, cy, Math.cos(ang)* (1.8 + s), Math.sin(ang)*(1.8 + s), 6));
      }
    } else {
      // spawn from outer ring heading inward-ish
      const ang = Math.random()*Math.PI*2;
      const dist = Math.max(innerWidth, innerHeight)*0.6;
      const x = cx + Math.cos(ang)*dist;
      const y = cy + Math.sin(ang)*dist;
      const vx = (cx - x) / (120 + Math.random()*80) * (1 + s*0.25);
      const vy = (cy - y) / (120 + Math.random()*80) * (1 + s*0.25);
      for (let i = 0; i < Math.max(2, Math.floor(s*2)); i++) {
        const jx = (Math.random()-0.5)*0.6, jy = (Math.random()-0.5)*0.6;
        notes.push(new Note(x, y, vx + jx, vy + jy, 5));
      }
    }
  }

  class Note {
    constructor(x,y,vx,vy,r=5) {
      this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=r;
      this.age=0; this.ttl = 12*60; // ~12s
      this.spawnTime = currentTime();
    }
    step() {
      this.x += this.vx; this.y += this.vy; this.age++;
      // fade
      return this.age < this.ttl && this.x>-50 && this.y>-50 && this.x<innerWidth+50 && this.y<innerHeight+50;
    }
    draw() {
      const a = Math.max(0, 1 - this.age/this.ttl);
      ctx.globalAlpha = 0.85 * a;
      ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // ===== Main loop =====
  let lastT = performance.now();
  function loop(now=performance.now()) {
    if (!playing) return;
    const dt = Math.min(33, now - lastT); lastT = now;

    // clear
    ctx.clearRect(0,0,innerWidth,innerHeight);
    // background sparkle
    drawStars(now);

    // spawn notes in sync with audio time
    const t = currentTime();
    hud.textContent = fmtTime(t) + ' / ' + fmtTime(trackBuffer.duration);

    while (nextEventIdx < levelEvents.length && levelEvents[nextEventIdx].t <= t) {
      spawnFromEvent(levelEvents[nextEventIdx]);
      nextEventIdx++;
    }

    // update / draw notes
    ctx.save();
    ctx.fillStyle = 'white';
    for (let i = notes.length-1; i >= 0; i--) {
      if (!notes[i].step()) notes.splice(i,1);
      else notes[i].draw();
    }
    ctx.restore();

    // player
    if (player.iFrames > 0) player.iFrames--;
    ctx.save();
    if ((player.iFrames % 6) < 3) {
      ctx.fillStyle = '#7dd3fc';
      ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // collisions
    if (player.alive && player.iFrames === 0) {
      for (const n of notes) {
        const dx = n.x - player.x, dy = n.y - player.y;
        if (dx*dx + dy*dy <= (n.r + player.r)*(n.r + player.r)) {
          playerHit();
          break;
        }
      }
    }

    requestAnimationFrame(loop);
  }

  function playerHit() {
    player.iFrames = 120; // 2s invulnerable
    // little flash
    flash(180);
  }

  function showEndScreen() {
    ui.style.display = 'grid';
    statusEl.innerHTML = `Track finished. <b>Events:</b> ${levelEvents.length}. Choose another file to play again.`;
    buildBtn.disabled = false;
  }

  function drawStars(now) {
    const w = innerWidth, h = innerHeight;
    const t = now * 0.001;
    for (let i = 0; i < 80; i++) {
      const x = (i*73 % w), y = ((i*199) % h);
      const s = (Math.sin(t*2 + i)*0.5 + 0.5) * 2 + 0.5;
      ctx.globalAlpha = 0.15 + s*0.05;
      ctx.fillStyle = '#c9d2ff';
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  function flash(ms=120) {
    const end = performance.now() + ms;
    function f(n=performance.now()) {
      const a = Math.max(0, (end - n) / ms);
      if (a <= 0) return;
      ctx.save();
      ctx.globalAlpha = a*0.35;
      ctx.fillStyle = '#7dd3fc';
      ctx.fillRect(0,0,innerWidth,innerHeight);
      ctx.restore();
      requestAnimationFrame(f);
    }
    f();
  }

  const fmtTime = s => {
    s = Math.max(0, s|0);
    const m = (s/60)|0, ss = (s%60)|0;
    return m.toString().padStart(2,'0') + ':' + ss.toString().padStart(2,'0');
  };
})();
</script>
</body>
</html>
